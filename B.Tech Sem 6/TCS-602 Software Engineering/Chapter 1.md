# Chapter 1

## Software

- Instructions that executed provide desired features, function and performance.
- Data structures that enable the program to adequately store and manipulate information.
- Documentation that describes the operation and use of the program.
- **Custom / Bespoke:** Software created for a particular customer.
- **Off the Shelf / Generic:** Software created for a large audience / public.

## Engineering

- The study of using scientific principles to design and build machines, structures and other things, including bridges, roads, vehicles and buildings.
- The art or science of making practical application of the knowledge of pure sciences, as physics or chemistry, as in the construction of engines, bridges, building, mines, ships and chemical plants.

## Software Engineering

Using scientific principles, along with different technologies, tools, and applications/principles of management in constructing a software.

### IEEE Definition

The application of a systematic, disciplined, quantifiable approach to the development, operation and maintenance of software, i.e. the application of engineering to software.

Software engineering is the establishment and use of sound engineering principles in order to obtain economically, software that is reliable and works efficiently on real machines.

### Objectives of Software Engineering

- Engineering is about quality within schedule and budget.
- Software Engineering is a disciplined and systematic approach to develop quality software.
- Software that is delivered on time, within budget and that satisfies its requirements.
- It relies on past experiences for techniques, methodologies and guidelines.

### Engineering Process

- Concerned from specification to maintaining the system.
- Engineers apply theories, methods and tools where these are appropriate.
- Discover solutions to problems even when there are no applicable theories and methods.

## Origin of Software Engineering

- Term 'Software Engineering' was first proposed in 1968 at a NATO conference held to discuss what was then called the software crisis.
- It became clear that individual approaches to program development did not scale up to large and complex software systems.

## Software Crisis

Software products are difficult to alter, debug and enhance; use resources non-optimally; often fail to meet the user requirements; are far from being reliable; frequently crash and are often delivered late.

## Software Myths

Roger Pressman (1997) describes several common beliefs or myths that software managers, customers and developers believe falsely.

He describes these myths as misleading attitudes that have caused serious problems.

### Types

- Manager's Myths
- Developer's Myths
- Customer's Myths

### Manager's Myths

**Myth:** We already have a bool that's full of standards and procedures for building software; won't that provide my people with everything they need to know?

**Reality:** The book of standards may very well exist, but is it used? Are software practitioners aware of its existence? Is it complete? Is it streamlined to improve time to delivery while still maintaining a focus on quality? In many cases, the answer to all of these questions is no.

**Myth:** My people have state of art software development tools, after all, we buy them the newest computers.

**Reality:** It takes much more than the latest model mainframe, workstation or PC to do high quality software development. Computer-aided software engineering tools are more important than hardware for achieving good quality and productivity, yet the majority of software developers still do not use them effectively.

**Myth** If we get behind schedule, we can add more programers and catch up (sometimes called the **Mongolian Horde concept**)

**Reality:** Software development is not a mechanical process like manufacturing, adding people to a late software project makes it later.

**Myth:** If I decide to outsource the software project to a third party, I can just relax and let that firm build it.

**Reality:** If an organization does not understand how to manage and control software projects internally, it will invariably struggle when it outsources software projects.

### Developer's Myths

**Myth:** Once we write the program and get it to work, our job is done.

**Reality:** Someone once said that the sooner you begin writing code, the longer it'll take you to get done. Industry data indicate that between 60 to 80 percent of all effort expended on software will be expended after it is delivered to the customer for the first time.

**Myth:** Until I get the program running, I have no way of assessing its quality.

**Reality:** One of the most effective software quality assurance mechanisms can be applied from the inception of a project - the formal technical review. Software reviews are a quality filter that is more effective than testing for finding certain classes of software defects.

**Myth:** The only deliverable software work product for a successful project is the working program.

**Reality:** A working program is only one part of a software configuration that includes many elements. Documentation provides a foundation for successful engineering and, more importantly, guidance for software support.

**Myth:** Software engineering will make us create voluminous and unnecessary documentation and invariably slow us down.

**Reality:** Software engineering is not about creating documents. It is about creating quality. Better quality leads to reduced rework. And reduced rework results in faster delivery times.

### Customer's Myths

**Myth:** A general statement of objectives is sufficient to begin writing programs - we can fill in the details later.

**Reality:** A poor up-front definition is the major cause of failed software efforts. A normal and detailed description of the information domain, function, behavior, performance, interfaces, design constraints, and validation criteria is essential. These characteristic can be determined only after thorough communication between customers and developers.

**Myth:** Project requirements continually change, but change can be easily accommodated because the software is flexible.

**Reality:** Software requirements indeed change, but the impact of change varies with the time at which it is introduced.

## Software Requirement Specification

Suppose we are developing a Train Reservation System.

**What is that software going to do?**

### Functional Requirements

- It should be able to book tickets between two places.
- Make payments.
- Users can create their profiles.
- Allow for different payment methods.

### Non-Functional Requirements

- It should be able to book around 10000 tickets per second.
- It should confirm booking within 3 seconds.

All of this information is collected in a document called **Software Requirement Specification**.
